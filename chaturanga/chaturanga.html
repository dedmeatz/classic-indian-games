<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaturanga - Four Player Chess</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Metamorphous&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #fdfaf3;
            --cell-border: #2c2c2c;
            --red: #b22222;
            --blue: #0047ab;
            --yellow: #d4af37;
            --green: #1b4d3e;
            --text: #1a1a1a;
            --font-family: 'Metamorphous', serif;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 10px;
            font-family: var(--font-family);
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation;
            overflow-x: hidden;
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 2px solid #ddd;
            padding-bottom: 8px;
        }

        .header h1 {
            font-size: clamp(1.5rem, 6vw, 2.2rem);
            margin: 0;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 400;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 4px solid var(--cell-border);
            user-select: none;
            background: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .scoring-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 12px;
            gap: 6px;
        }

        .score-item {
            flex: 1;
            height: 48px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2px solid #333;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }

        .score-item span:first-child { font-size: 0.65rem; opacity: 0.9; text-transform: uppercase; margin-bottom: -2px; }

        #score-0 { background-color: var(--red); color: #fff; }
        #score-1 { background-color: var(--blue); color: #fff; }
        #score-2 { background-color: var(--yellow); color: #000; }
        #score-3 { background-color: var(--green); color: #fff; }

        .score-item.active {
            border-color: #000;
            transform: translateY(-2px);
            box-shadow: 0 4px 0px #000;
            z-index: 5;
        }

        .cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(20px, 7vw, 36px);
            cursor: pointer;
            border: 0.5px solid rgba(0,0,0,0.05);
        }

        .cell:nth-child(odd) { background-color: #fcfcfc; }
        .cell:nth-child(even) { background-color: #f4f4f4; }
        .cell.selected { background-color: rgba(212, 175, 55, 0.4) !important; }
        .cell.highlight::after {
            content: '';
            width: 25%;
            height: 25%;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 50%;
            position: absolute;
        }

        .piece {
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.2));
        }

        .piece.red { color: var(--red); }
        .piece.blue { color: var(--blue); }
        .piece.yellow { color: var(--yellow); }
        .piece.green { color: var(--green); }
        .piece.dead { opacity: 0.3; filter: grayscale(1); }

        .boat-svg { width: 0.8em; height: 0.8em; }

        .bottom-section {
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 0 4px;
        }

        .turn-indicator {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 3px solid #000;
            flex: 1;
            margin-right: 12px;
            text-align: center;
            box-shadow: 4px 4px 0px #000;
            font-weight: bold;
        }

        .controls-row { display: flex; gap: 8px; }

        .icon-btn {
            background: #1a1a1a;
            color: #fff;
            border: none;
            border-radius: 8px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 3px 3px 0px rgba(0,0,0,0.3);
        }

        .icon-btn:active { transform: translate(1px, 1px); box-shadow: none; }
        .icon-btn svg { width: 22px; height: 22px; }

        /* Rules Modal Styling */
        #rules-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            padding: 24px;
            border: 4px solid #1a1a1a;
            z-index: 1000;
            width: 90%;
            max-width: 420px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 12px 12px 0px #000;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 999;
        }

        h3 { border-bottom: 2px solid #000; padding-bottom: 5px; }

        /* Icon alignment in rules list */
        .rule-list { list-style: none; padding: 0; margin: 0; font-size: 0.95rem; }
        .rule-list li { display: flex; align-items: flex-start; gap: 10px; margin-bottom: 12px; line-height: 1.4; }
        .rule-icon { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 1.4rem; color: #1a1a1a; }
    </style>
</head>
<body>

    <div class="header">
        <h1>Chaturanga</h1>
    </div>

    <div class="main-container">
        <div id="board"></div>

        <div class="scoring-bar">
            <div id="score-0" class="score-item"><span>Red</span><span class="val">0</span></div>
            <div id="score-1" class="score-item"><span>Blue</span><span class="val">0</span></div>
            <div id="score-2" class="score-item"><span>Yellow</span><span class="val">0</span></div>
            <div id="score-3" class="score-item"><span>Green</span><span class="val">0</span></div>
        </div>

        <div class="bottom-section">
            <div class="turn-indicator" id="status">RED</div>
            
            <div class="controls-row">
                <button class="icon-btn" onclick="initGame()" title="Reset Game">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                </button>
                <button class="icon-btn" style="background:#fff; color:#000; border:2px solid #000" onclick="toggleRules()" title="Show Rules">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M12 16v-4"></path>
                        <path d="M12 8h.01"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="overlay" onclick="toggleRules()"></div>
    <div id="rules-modal">
        <h3 style="margin: 0 0 15px 0; text-transform: uppercase;">Laws of the Game</h3>
        <ul class="rule-list">
            <li>
                <div class="rule-icon"><svg viewBox="0 0 24 24" style="width:20px;height:20px;"><path d="M4 15c0 0 2 2 8 2s8-2 8-2l-2 4H6l-2-4zM12 2v11M12 4l6 6h-6" stroke="currentColor" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg></div>
                <div><strong>Boat:</strong> Moves like a <strong>Bishop</strong>. Unrestricted diagonals in all directions.</div>
            </li>
            <li>
                <div class="rule-icon">‚ôù</div>
                <div><strong>Elephant:</strong> Jumps exactly <strong>2 squares</strong> diagonally. Can leap over other pieces.</div>
            </li>
            <li>
                <div class="rule-icon">‚ôû</div>
                <div><strong>Knight:</strong> Standard 'L' move. Jumps over pieces.</div>
            </li>
            <li>
                <div class="rule-icon">‚ôü</div>
                <div><strong>Pawn:</strong> Moves 1 forward, captures 1 diagonally. Promotes to <strong>Boat</strong> at the edge.</div>
            </li>
            <li>
                <div class="rule-icon">‚ôö</div>
                <div><strong>King:</strong> Moves 1 square in any direction. Capture the King to eliminate a player.</div>
            </li>
            <li>
                <div class="rule-icon">üíÄ</div>
                <div><strong>Elimination:</strong> Captured pieces of an eliminated player stay on the board as "ghosts" and can be captured for points.</div>
            </li>
        </ul>
        <button onclick="toggleRules()" style="width: 100%; margin-top: 15px; padding: 14px; background: #1a1a1a; color: #fff; border: none; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;">Dismiss</button>
    </div>

    <script>
        const BOARD_SIZE = 8;
        const PLAYERS = ['RED', 'BLUE', 'YELLOW', 'GREEN'];
        const PIECES = { king: '‚ôö', knight: '‚ôû', bishop: '‚ôù', pawn: '‚ôü' };
        const BOAT_SVG = `<svg viewBox="0 0 24 24" class="boat-svg"><path d="M4 15c0 0 2 2 8 2s8-2 8-2l-2 4H6l-2-4zM12 2v11M12 4l6 6h-6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const SCORES_VAL = { pawn: 1, knight: 3, king: 3, bishop: 5, boat: 5 };

        let boardState = [];
        let currentPlayer = 0;
        let selectedCell = null;
        let scores = [0, 0, 0, 0];
        let deadPlayers = [false, false, false, false];

        function toggleRules() {
            const m = document.getElementById('rules-modal');
            const o = document.getElementById('overlay');
            const vis = m.style.display === 'block';
            m.style.display = vis ? 'none' : 'block';
            o.style.display = vis ? 'none' : 'block';
        }

        function initGame() {
            boardState = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
            currentPlayer = 0;
            scores = [0, 0, 0, 0];
            deadPlayers = [false, false, false, false];
            selectedCell = null;

            setupPlayer(0, 7, 0, 0, 1); 
            setupPlayer(1, 0, 0, 1, 0); 
            setupPlayer(2, 0, 7, 0, -1); 
            setupPlayer(3, 7, 7, -1, 0); 

            render();
            updateUI();
        }

        function setupPlayer(pIdx, r, c, dr, dc) {
            const colors = ['red', 'blue', 'yellow', 'green'];
            const color = colors[pIdx];
            const types = ['boat', 'knight', 'bishop', 'king'];
            
            for(let i = 0; i < 4; i++) {
                let pr = (dr === 0) ? r : r + (i * dr);
                let pc = (dr === 0) ? c + (i * dc) : c;
                boardState[pr][pc] = { type: types[i], color, player: pIdx };
            }

            for (let i = 0; i < 4; i++) {
                let pr, pc;
                if (dr === 0) {
                    pr = r + (pIdx === 0 ? -1 : 1);
                    pc = c + (i * dc);
                } else {
                    pr = r + (i * dr);
                    pc = c + (pIdx === 1 ? 1 : -1);
                }
                boardState[pr][pc] = { type: 'pawn', color, player: pIdx };
            }
        }

        function render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r; cell.dataset.c = c;
                    
                    const piece = boardState[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('span');
                        pieceEl.className = `piece ${piece.color} ${deadPlayers[piece.player] ? 'dead' : ''}`;
                        if (piece.type === 'boat') pieceEl.innerHTML = BOAT_SVG;
                        else pieceEl.innerText = PIECES[piece.type];
                        cell.appendChild(pieceEl);
                    }
                    if (selectedCell && selectedCell.r === r && selectedCell.c === c) cell.classList.add('selected');
                    cell.onclick = () => handleCellClick(r, c);
                    boardEl.appendChild(cell);
                }
            }
        }

        function handleCellClick(r, c) {
            const piece = boardState[r][c];
            if (selectedCell) {
                if (isValidMove(selectedCell.r, selectedCell.c, r, c)) {
                    makeMove(selectedCell.r, selectedCell.c, r, c);
                    return;
                }
                selectedCell = null;
                render();
            }
            if (piece && piece.player === currentPlayer && !deadPlayers[currentPlayer]) {
                selectedCell = { r, c };
                render();
                highlightMoves(r, c);
            }
        }

        function highlightMoves(r, c) {
            document.querySelectorAll('.cell').forEach(cell => {
                if (isValidMove(r, c, parseInt(cell.dataset.r), parseInt(cell.dataset.c))) cell.classList.add('highlight');
            });
        }

        function isValidMove(sr, sc, tr, tc) {
            const piece = boardState[sr][sc];
            const target = boardState[tr][tc];
            if (target && target.player === piece.player && !deadPlayers[target.player]) return false;

            const dr = Math.abs(tr - sr);
            const dc = Math.abs(tc - sc);

            switch (piece.type) {
                case 'king': return dr <= 1 && dc <= 1;
                case 'knight': return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
                case 'bishop': return dr === 2 && dc === 2;
                case 'boat': return dr === dc && isPathClear(sr, sc, tr, tc);
                case 'pawn': return isValidPawnMove(sr, sc, tr, tc, piece.player);
            }
            return false;
        }

        function isValidPawnMove(sr, sc, tr, tc, pIdx) {
            const dr = tr - sr, dc = tc - sc;
            const target = boardState[tr][tc];
            let moveR = 0, moveC = 0;
            if (pIdx === 0) moveR = -1; 
            else if (pIdx === 1) moveC = 1;
            else if (pIdx === 2) moveR = 1; 
            else if (pIdx === 3) moveC = -1;

            if (!target && dr === moveR && dc === moveC) return true;
            if (target) {
                if (pIdx === 0 || pIdx === 2) return Math.abs(dc) === 1 && dr === moveR;
                else return Math.abs(dr) === 1 && dc === moveC;
            }
            return false;
        }

        function isPathClear(sr, sc, tr, tc) {
            const dr = Math.sign(tr - sr);
            const dc = Math.sign(tc - sc);
            let r = sr + dr;
            let c = sc + dc;
            while (r !== tr || c !== tc) {
                if (boardState[r][c]) return false;
                r += dr; c += dc;
            }
            return true;
        }

        function makeMove(sr, sc, tr, tc) {
            const piece = boardState[sr][sc];
            const target = boardState[tr][tc];

            if (target) {
                if (deadPlayers[target.player]) {
                    if (target.type === 'king') scores[currentPlayer] += 3;
                } else {
                    scores[currentPlayer] += SCORES_VAL[target.type];
                    if (target.type === 'king') deadPlayers[target.player] = true;
                }
            }

            boardState[tr][tc] = piece;
            boardState[sr][sc] = null;

            if (piece.type === 'pawn') {
                if ((piece.player === 0 && tr === 0) || (piece.player === 1 && tc === 7) ||
                    (piece.player === 2 && tr === 7) || (piece.player === 3 && tc === 0)) piece.type = 'boat';
            }
            selectedCell = null;
            nextTurn();
        }

        function nextTurn() {
            const activeCount = deadPlayers.filter(d => !d).length;
            if (activeCount <= 1) { endGame(); return; }
            let count = 0;
            do {
                currentPlayer = (currentPlayer + 1) % 4;
                count++;
            } while (deadPlayers[currentPlayer] && count < 4);
            render();
            updateUI();
        }

        function updateUI() {
            const turnTile = document.getElementById('status');
            const colors = ['var(--red)', 'var(--blue)', 'var(--yellow)', 'var(--green)'];
            const textColors = ['#fff', '#fff', '#000', '#fff'];

            PLAYERS.forEach((p, i) => {
                const el = document.getElementById(`score-${i}`);
                el.querySelector('.val').innerText = scores[i];
                el.classList.toggle('active', i === currentPlayer);
                el.style.opacity = deadPlayers[i] ? "0.4" : "1.0";
            });

            turnTile.innerText = `${PLAYERS[currentPlayer]}'s TURN`;
            turnTile.style.backgroundColor = colors[currentPlayer];
            turnTile.style.color = textColors[currentPlayer];
        }

        function endGame() {
            render();
            const winnerIdx = scores.indexOf(Math.max(...scores));
            const turnTile = document.getElementById('status');
            turnTile.innerHTML = `üèÜ Winner: ${PLAYERS[winnerIdx]}`;
            turnTile.style.backgroundColor = 'black';
            turnTile.style.color = 'gold';
        }

        window.onload = initGame;
    </script>
</body>
</html>